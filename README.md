D1					2020.6.16
BEGIN/END{
code
}		#在程序运行前/结尾处调用

=begin
.
.
.
=end	#注释其中内容

整型相除结果还是整型，要表达为浮点数。

.each do 数组中是字符串则不需要换行符
 数组中是键值对则需要换行符

(1..5)两个点包括首尾，三个点不包括结尾


D2		下雨，没跑步	2020.6.18

对象、类
局部变量（未初始化被解释为调用一个不带参数的方法、类变量（必须初始化）、实例变量、全局变量（默认为nil）、伪变量（保留值，不可改）
全局变量 $x
在所有类中具有相同的值
局部变量 _x或小写字母开头
局部变量的作用域从 class、module、def 或 do 到相对应的结尾或者从左大括号到右大括号 {}。

实例变量和类变量还没理解具体的用法

initialize方法在new时执行，对对象初始化

运算符
<=> 大于为1，等于为0，小于为-1
.eql有相同类型且相同的值为真
equal?有相同的对象id
位运算符（二进制下）
&与		|或		^有且只有一个为1		~有符号补码	<<   >>左右移位
逻辑运算符
and or 操作数为真
&& ||操作数非零

D3			2020.6.19
循环
while/until  do			for   in
(expression).each do |variable[, variable...]| code end
break 跳出循环		next跳过本次循环
redo	重新开始最内部循环的该次迭代，不检查循环条件。
方法
定义方法可以有默认参数
方法默认的返回值是最后一个语句的值
参数数量可变(*test)
alias B A		A的别名是B
块
块和函数名相同，块内操作在函数中通过yield调用
yield可带多个参数，块中{|a,b| statement}
但是如果方法的最后一个参数前带有 &，那么可以向该方法传递一个块，且这个块可被赋给最后一个参数。
BEGIN 块按照它们出现的顺序执行。END 块按照它们出现的相反顺序执行。

require
 $LOAD_PATH << '.' 让 Ruby 知道必须在当前目录中搜索被引用的文件。
::寻找常量、类、方法（均被视为常量）
函数名中带有点号，则不需要实例化
mixins的继承方式

D4		2020.6.20		
单引号内部不会转义（内部的单引号需要\抑制）且不会进行运算
数组在生成时可以直接在Array.new后面赋值
1、（5,"abc"）		2、（5）{ "abc" }		#生成5个同样的"abc"
还可以Array.[   ]或Array.[](   )来赋值

公共的字符串方法：
字符串的unpack指令：
公共的数组方法：
数组的pack指令：
公共的哈希方法：
上面的五个表需要在应用中练习

Ruby中有默认的Time类
===包括判断
其他内容：
三个等号的比较操作===
通常情况下这中方式与==是一样的，但是在某些特定情况下，===有特殊的含义：
在Range中===用于判断等号右边的对象是否包含于等号左边的Range；
正则表达式中用于判断一个字符串是否匹配模式，
Class定义===来判断一个对象是否为类的实例，
Symbol定义===来判断等号两边的符号对象是否相同。


Ruby的范围a-z 、0-9
作为序列的范围
作为条件的范围
作为间隔的范围：检测指定的值是否在范围内。由前文的===判断符
